<?xml version="1.0"?>
<doc>
    <assembly>
        <name>NServiceBus.Azure.Transports.WindowsAzureServiceBus</name>
    </assembly>
    <members>
        <member name="M:NServiceBus.Transport.AzureServiceBus.MessagePump.DetermineTopologyOperator(System.String)">
            <summary>
            Determine what topology operator to use.
            For the main input queue, cache and re-use the same topology operator.
            For satellite input queues, create a new topology operator.
            </summary>
        </member>
        <member name="T:NServiceBus.Transport.AzureServiceBus.ReceiveContext">
            <summary>
            Holds on to the the receive metadata
            - the original message so that it can be completed or abandoned when processing is done
            - the queue where it came from, so that sends can go via that queue to emulate send transactions
            </summary>
        </member>
        <member name="M:NServiceBus.Transport.AzureServiceBus.ReadOnlySettingsExtensions.GetConditional``1(NServiceBus.Settings.ReadOnlySettings,System.String,System.String)">
            <summary>Apply conditional setting if condition exists</summary>
        </member>
        <member name="M:NServiceBus.Transport.AzureServiceBus.IBrokerSideSubscriptionFilter.Serialize">
            <summary>
            serialized the filter into native format, so that it can be injected into the broker (subscription case)
            </summary>
        </member>
        <member name="M:NServiceBus.Transport.AzureServiceBus.IClientSideSubscriptionFilter.Execute(System.Object)">
            <summary>
            executes a filter in memory, if it is impossible to inject it into the broker (eventhub case)
            </summary>
        </member>
        <member name="T:NServiceBus.Transport.AzureServiceBus.IOperateTopology">
            <summary>
            Operational aspects of running on top of the topology
            Takes care of the topology and it's specific state at runtime
            Examples
            Decisions of currently active namespace go here f.e.
            So is the list of notifiers etc...
            etc..
            </summary>
        </member>
        <member name="M:NServiceBus.AzureServiceBusDiscriminatorBasedIndividualizationSettingsExtensions.DiscriminatorGenerator(NServiceBus.AzureServiceBusIndividualizationExtensionPoint{NServiceBus.DiscriminatorBasedIndividualization},System.Func{System.String,System.String})">
            <summary>
            Set discriminator generator for <see cref="T:NServiceBus.DiscriminatorBasedIndividualization" /> individualization strategy.
            </summary>
            <param name="individualizationStrategy">DiscriminatorBasedIndividualization</param>
            <param name="discriminatorGenerator">Generator function that receives an endpoint name and returns individualized endpoint name.</param>
        </member>
        <member name="M:NServiceBus.AzureServiceBusNamespaceManagersSettings.NamespaceManagerSettingsFactory(System.Func{System.String,Microsoft.ServiceBus.NamespaceManagerSettings})">
            <summary>
            Customize <see cref="T:Microsoft.ServiceBus.NamespaceManager"/> creation.
            </summary>
        </member>
        <member name="M:NServiceBus.AzureServiceBusNamespaceManagersSettings.TokenProvider(System.Func{System.String,Microsoft.ServiceBus.TokenProvider})">
            <summary>
            Customize the token provider.
            </summary>
        </member>
        <member name="M:NServiceBus.AzureServiceBusNamespaceManagersSettings.RetryPolicy(Microsoft.ServiceBus.RetryPolicy)">
            <summary>
            Retry policy configured on Namespace Manager level.
            <remarks>Default is RetryPolicy.Default</remarks>
            </summary>
        </member>
        <member name="M:NServiceBus.AzureServiceBusNamespaceRoutingSettings.AddNamespace(System.String,System.String)">
            <summary>
            Adds a namespace for routing.
            </summary>
        </member>
        <member name="T:NServiceBus.SizeInMegabytes">
            <summary>
            Entity size (queues and topics)
            </summary>
        </member>
        <member name="M:NServiceBus.AzureServiceBus.Topology.MetaModel.SatelliteTransportAddressCollection.Contains(System.String)">
            <summary>
            Does transport address belong to a known satellite?
            </summary>
            <remarks>Performs <see cref="F:System.StringComparison.OrdinalIgnoreCase"/> equality check.</remarks>
        </member>
        <member name="M:NServiceBus.AzureServiceBusMessageReceiverSettings.ReceiveMode(Microsoft.ServiceBus.Messaging.ReceiveMode)">
            <summary>
            Brokered messages receive mode.
            <remarks>Default is ReceiveMode.PeekLock.</remarks>
            </summary>
        </member>
        <member name="M:NServiceBus.AzureServiceBusMessageReceiverSettings.PrefetchCount(System.Int32)">
            <summary>
            Number of messages to pre-fetch in receive operation.
            </summary>
        </member>
        <member name="M:NServiceBus.AzureServiceBusMessageReceiverSettings.RetryPolicy(Microsoft.ServiceBus.RetryPolicy)">
            <summary>
            Retry policy.
            <remarks>Default is RetryPolicy.Default</remarks>
            </summary>
        </member>
        <member name="M:NServiceBus.AzureServiceBusMessageReceiverSettings.AutoRenewTimeout(System.TimeSpan)">
            <summary>
            Maximum duration within which the message lock will be renewed automatically. 
            <remarks>This value should be greater than the message lock duration. Default is 5 minutes.</remarks>
            </summary>
        </member>
        <member name="M:NServiceBus.AzureServiceBusMessageSenderSettings.RetryPolicy(Microsoft.ServiceBus.RetryPolicy)">
            <summary>
            Retry policy.
            <remarks>Default is RetryPolicy.Default</remarks>
            </summary>
        </member>
        <member name="M:NServiceBus.AzureServiceBusMessageSenderSettings.BackOffTimeOnThrottle(System.TimeSpan)">
            <summary>
            Time period to wait until next attempt is made after operation is throttled.
            <remarks>Default is 10 seconds.</remarks>
            </summary>
        </member>
        <member name="M:NServiceBus.AzureServiceBusMessageSenderSettings.RetryAttemptsOnThrottle(System.Int32)">
            <summary>
            Number of retries when operation is throttled.
            <remarks>Default is 5 attempts.</remarks>
            </summary>
        </member>
        <member name="M:NServiceBus.AzureServiceBusMessageSenderSettings.MaximuMessageSizeInKilobytes(System.Int32)">
            <summary>
            Maximum message size allowed for sending.
            <remarks>Default is 256KB.</remarks>
            </summary>
        </member>
        <member name="M:NServiceBus.AzureServiceBusMessageSenderSettings.MessageSizePaddingPercentage(System.Int32)">
            <summary>
            Message size padding percentage used for sending batched messages.
            <remarks>Default is 5%.</remarks>
            </summary>
        </member>
        <member name="M:NServiceBus.AzureServiceBusMessageSenderSettings.OversizedBrokeredMessageHandler``1(``0)">
            <summary>
            Behavior for oversized messages.
            <remarks>Default is throw an exception using <see cref="T:NServiceBus.Transport.AzureServiceBus.ThrowOnOversizedBrokeredMessages"/>.</remarks>
            </summary>
        </member>
        <member name="M:NServiceBus.AzureServiceBusMessagingFactoriesSettings.MessagingFactorySettingsFactory(System.Func{System.String,Microsoft.ServiceBus.Messaging.MessagingFactorySettings})">
            <summary>
            Customize <see cref="T:Microsoft.ServiceBus.Messaging.MessagingFactory"/> creation.
            </summary>
        </member>
        <member name="M:NServiceBus.AzureServiceBusMessagingFactoriesSettings.NumberOfMessagingFactoriesPerNamespace(System.Int32)">
            <summary>
            Number of messaging factories per namespace to create senders and receivers.
            <remarks>Default is 5.</remarks>
            </summary>
        </member>
        <member name="M:NServiceBus.AzureServiceBusMessagingFactoriesSettings.RetryPolicy(Microsoft.ServiceBus.RetryPolicy)">
            <summary>
            Retry policy configured on MessagingFactory level.
            <remarks>Default is RetryPolicy.Default</remarks>
            </summary>
        </member>
        <member name="M:NServiceBus.AzureServiceBusMessagingFactoriesSettings.BatchFlushInterval(System.TimeSpan)">
            <summary>
            Batch flush interval configured on MessagingFactory level.
            <remarks>Default is 0.5 seconds.</remarks>
            </summary>
        </member>
        <member name="M:NServiceBus.AzureServiceBusTransportExtensions.BrokeredMessageBodyType(NServiceBus.TransportExtensions{NServiceBus.AzureServiceBusTransport},NServiceBus.Transport.AzureServiceBus.SupportedBrokeredMessageBodyTypes)">
            <summary>
            <see cref="T:Microsoft.ServiceBus.Messaging.BrokeredMessage"/> body type used to store and retrieve messages.
            <remarks>Default is SupportedBrokeredMessageBodyTypes.ByteArray.</remarks>
            </summary>
        </member>
        <member name="M:NServiceBus.AzureServiceBusTransportExtensions.UseBrokeredMessageToIncomingMessageConverter``1(NServiceBus.TransportExtensions{NServiceBus.AzureServiceBusTransport})">
            <summary>
            Provide custom implementation to convert brokered message to incoming message
            </summary>
        </member>
        <member name="M:NServiceBus.AzureServiceBusTransportExtensions.UseOutgoingMessageToBrokeredMessageConverter``1(NServiceBus.TransportExtensions{NServiceBus.AzureServiceBusTransport})">
            <summary>
            Provide custom implementation to convert outgoing message to brokered message
            </summary>
        </member>
        <member name="M:NServiceBus.AzureServiceBusTransportExtensions.NumberOfClientsPerEntity(NServiceBus.TransportExtensions{NServiceBus.AzureServiceBusTransport},System.Int32)">
            <summary>
            Number of senders and receivers per entity.
            <remarks>Default is 5.</remarks>
            </summary>
        </member>
        <member name="M:NServiceBus.AzureServiceBusTransportExtensions.SendViaReceiveQueue(NServiceBus.TransportExtensions{NServiceBus.AzureServiceBusTransport},System.Boolean)">
            <summary>
            Use receive queue to dispatch outgoing messages.
            <remarks>Default is true.</remarks>
            </summary>
        </member>
        <member name="M:NServiceBus.AzureServiceBusTransportExtensions.ConnectivityMode(NServiceBus.TransportExtensions{NServiceBus.AzureServiceBusTransport},Microsoft.ServiceBus.ConnectivityMode)">
            <summary>
            Connectivity mode used by Azure Service Bus.
            <remarks>Default is ConnectivityMode.Tcp</remarks>
            </summary>
        </member>
        <member name="M:NServiceBus.AzureServiceBusTransportExtensions.TransportType(NServiceBus.TransportExtensions{NServiceBus.AzureServiceBusTransport},Microsoft.ServiceBus.Messaging.TransportType)">
            <summary>
            Transport type used by Azure Service Bus.
            <remarks>Default is TransportType.NetMessaging</remarks>
            </summary>
        </member>
        <member name="M:NServiceBus.AzureServiceBusTransportExtensions.MessageReceivers(NServiceBus.TransportExtensions{NServiceBus.AzureServiceBusTransport})">
            <summary>
            Access to message receivers configuration.
            </summary>
        </member>
        <member name="M:NServiceBus.AzureServiceBusTransportExtensions.MessageSenders(NServiceBus.TransportExtensions{NServiceBus.AzureServiceBusTransport})">
            <summary>
            Access to message senders configuration.
            </summary>
        </member>
        <member name="M:NServiceBus.AzureServiceBusTransportExtensions.MessagingFactories(NServiceBus.TransportExtensions{NServiceBus.AzureServiceBusTransport})">
            <summary>
            Access to messaging factories configuration.
            </summary>
        </member>
        <member name="M:NServiceBus.AzureServiceBusTransportExtensions.NamespaceManagers(NServiceBus.TransportExtensions{NServiceBus.AzureServiceBusTransport})">
            <summary>
            Access to namespace managers configuration.
            </summary>
        </member>
        <member name="M:NServiceBus.AzureServiceBusTransportExtensions.UseNamespaceAliasesInsteadOfConnectionStrings(NServiceBus.TransportExtensions{NServiceBus.AzureServiceBusTransport})">
            <summary>
            Force usage of namespace aliases instead of raw connection strings.
            </summary>
        </member>
        <member name="M:NServiceBus.AzureServiceBusTransportExtensions.DefaultNamespaceAlias(NServiceBus.TransportExtensions{NServiceBus.AzureServiceBusTransport},System.String)">
            <summary>
            Override default namespace alias.
            </summary>
        </member>
        <member name="M:NServiceBus.AzureServiceBusTransportExtensions.Queues(NServiceBus.TransportExtensions{NServiceBus.AzureServiceBusTransport})">
            <summary>
            Access to queues configuration.
            </summary>
        </member>
        <member name="M:NServiceBus.AzureServiceBusTransportExtensions.Topics(NServiceBus.TransportExtensions{NServiceBus.AzureServiceBusTransport})">
            <summary>
            Access to topics configuration.
            </summary>
        </member>
        <member name="M:NServiceBus.AzureServiceBusTransportExtensions.Subscriptions(NServiceBus.TransportExtensions{NServiceBus.AzureServiceBusTransport})">
            <summary>
            Access to subscriptions configuration.
            </summary>
        </member>
        <member name="M:NServiceBus.AzureServiceBusTransportExtensions.NamespacePartitioning(NServiceBus.TransportExtensions{NServiceBus.AzureServiceBusTransport})">
            <summary>
            Access to namespace partitioning configuration.
            </summary>
        </member>
        <member name="M:NServiceBus.AzureServiceBusTransportExtensions.NamespaceRouting(NServiceBus.TransportExtensions{NServiceBus.AzureServiceBusTransport})">
            <summary>
            Access to namespace routing.
            </summary>
        </member>
        <member name="M:NServiceBus.AzureServiceBusTransportExtensions.Composition(NServiceBus.TransportExtensions{NServiceBus.AzureServiceBusTransport})">
            <summary>
            Access to entities composition configuration.
            </summary>
        </member>
        <member name="M:NServiceBus.AzureServiceBusTransportExtensions.Sanitization(NServiceBus.TransportExtensions{NServiceBus.AzureServiceBusTransport})">
            <summary>
            Access to entities path/name sanitization configuration.
            </summary>
        </member>
        <member name="M:NServiceBus.AzureServiceBusTransportExtensions.Individualization(NServiceBus.TransportExtensions{NServiceBus.AzureServiceBusTransport})">
            <summary>
            Access to input queue individualization configuration.
            </summary>
        </member>
        <member name="M:NServiceBus.AzureServiceBusCompositionSettings.UseStrategy``1">
            <summary>
            Provide composition strategy to use.
            <remarks>Default is <see cref="T:NServiceBus.FlatComposition"/></remarks>
            <seealso cref="T:NServiceBus.HierarchyComposition"/>
            </summary>
        </member>
        <member name="M:NServiceBus.AzureServiceBusIndividualizationSettings.UseStrategy``1">
            <summary>
            Provide individualization strategy to use.
            <remarks>Default is <see cref="T:NServiceBus.DiscriminatorBasedIndividualization"/></remarks>
            <seealso cref="T:NServiceBus.CoreIndividualization"/>
            <seealso cref="T:NServiceBus.DiscriminatorBasedIndividualization"/>
            </summary>
        </member>
        <member name="M:NServiceBus.AzureServiceBusNamespacePartitioningSettings.UseStrategy``1">
            <summary>
            Namespace partitioning strategy to use.
            <remarks> Default is <see cref="T:NServiceBus.SingleNamespacePartitioning"/>. 
            Additional strategies are <see cref="T:NServiceBus.RoundRobinNamespacePartitioning"/>,
            <see cref="T:NServiceBus.FailOverNamespacePartitioning"/>,
            </remarks>
            </summary>
        </member>
        <member name="M:NServiceBus.AzureServiceBusNamespacePartitioningSettings.AddNamespace(System.String,System.String)">
            <summary>
            Adds a namespace for partitioning.
            </summary>
        </member>
        <member name="M:NServiceBus.AzureServiceBusQueueSettings.DescriptionFactory(System.Func{System.String,NServiceBus.Settings.ReadOnlySettings,Microsoft.ServiceBus.Messaging.QueueDescription})">
            <summary>
            Customize queue creation by providing <see cref="T:Microsoft.ServiceBus.Messaging.QueueDescription"/>.
            </summary>
        </member>
        <member name="M:NServiceBus.AzureServiceBusQueueSettings.ForwardDeadLetteredMessagesTo(System.String)">
            <summary>
            <remarks> Default is set not to forward.</remarks>
            </summary>
        </member>
        <member name="M:NServiceBus.AzureServiceBusQueueSettings.ForwardDeadLetteredMessagesTo(System.Func{System.String,System.Boolean},System.String)">
            <summary>
            <remarks> Default is set not to forward.</remarks>
            </summary>
        </member>
        <member name="M:NServiceBus.AzureServiceBusQueueSettings.EnableExpress(System.Boolean)">
            <summary>
            <remarks> Default is false.</remarks>
            </summary>
        </member>
        <member name="M:NServiceBus.AzureServiceBusQueueSettings.EnableExpress(System.Func{System.String,System.Boolean},System.Boolean)">
            <summary>
            <remarks> Default is false.</remarks>
            </summary>
        </member>
        <member name="M:NServiceBus.AzureServiceBusQueueSettings.AutoDeleteOnIdle(System.TimeSpan)">
            <summary>
            <remarks> Default is TimeSpan.MaxValue.</remarks>
            </summary>
        </member>
        <member name="M:NServiceBus.AzureServiceBusQueueSettings.EnablePartitioning(System.Boolean)">
            <summary>
            <remarks> Default is false.</remarks>
            </summary>
        </member>
        <member name="M:NServiceBus.AzureServiceBusQueueSettings.EnableBatchedOperations(System.Boolean)">
            <summary>
            <remarks> Default is true.</remarks>
            </summary>
        </member>
        <member name="M:NServiceBus.AzureServiceBusQueueSettings.MaxDeliveryCount(System.Int32)">
            <summary>
            <remarks> Default is 10.</remarks>
            </summary>
        </member>
        <member name="M:NServiceBus.AzureServiceBusQueueSettings.DuplicateDetectionHistoryTimeWindow(System.TimeSpan)">
            <summary>
            <remarks> Default is 10 minutes.</remarks>
            </summary>
        </member>
        <member name="M:NServiceBus.AzureServiceBusQueueSettings.EnableDeadLetteringOnMessageExpiration(System.Boolean)">
            <summary>
            <remarks> Default is false.</remarks>
            </summary>
        </member>
        <member name="M:NServiceBus.AzureServiceBusQueueSettings.DefaultMessageTimeToLive(System.TimeSpan)">
            <summary>
            <remarks> Default is TimeSpan.MaxValue.</remarks>
            </summary>
        </member>
        <member name="M:NServiceBus.AzureServiceBusQueueSettings.RequiresDuplicateDetection(System.Boolean)">
            <summary>
            <remarks> Default is false.</remarks>
            </summary>
        </member>
        <member name="M:NServiceBus.AzureServiceBusQueueSettings.MaxSizeInMegabytes(NServiceBus.SizeInMegabytes)">
            <summary>
            <remarks> Default is 1,024 MB.</remarks>
            </summary>
        </member>
        <member name="M:NServiceBus.AzureServiceBusQueueSettings.LockDuration(System.TimeSpan)">
            <summary>
            <remarks> Default is 30 seconds.</remarks>
            </summary>
        </member>
        <member name="M:NServiceBus.AzureServiceBusQueueSettings.SupportOrdering(System.Boolean)">
            <summary>
            <remarks> Default is false.</remarks>
            </summary>
        </member>
        <member name="M:NServiceBus.AzureServiceBusSanitizationSettings.UseQueuePathMaximumLength(System.Int32)">
            <summary>
            <remarks> Default is 260 characters.</remarks>
            </summary>
        </member>
        <member name="M:NServiceBus.AzureServiceBusSanitizationSettings.UseTopicPathMaximumLength(System.Int32)">
            <summary>
            <remarks> Default is 260 characters.</remarks>
            </summary>
        </member>
        <member name="M:NServiceBus.AzureServiceBusSanitizationSettings.UseSubscriptionPathMaximumLength(System.Int32)">
            <summary>
            <remarks> Default is 50 characters.</remarks>
            </summary>
        </member>
        <member name="M:NServiceBus.AzureServiceBusSanitizationSettings.UseRulePathMaximumLength(System.Int32)">
            <summary>
            <remarks> Default is 50 characters.</remarks>
            </summary>
        </member>
        <member name="M:NServiceBus.AzureServiceBusSanitizationSettings.UseStrategy``1">
            <summary>
            Strategy to use for sanitization of entity paths/names.
            <remarks> Default is <see cref="T:NServiceBus.ThrowOnFailedValidation"/>. For backward compatibility with <see cref="T:NServiceBus.EndpointOrientedTopology"/> use <see cref="T:NServiceBus.ValidateAndHashIfNeeded"/>.</remarks>
            </summary>
        </member>
        <member name="M:NServiceBus.AzureServiceBusSubscriptionSettings.DescriptionFactory(System.Func{System.String,System.String,NServiceBus.Settings.ReadOnlySettings,Microsoft.ServiceBus.Messaging.SubscriptionDescription})">
            <summary>
            Customize subscription creation by providing <see cref="T:Microsoft.ServiceBus.Messaging.SubscriptionDescription"/>.
            </summary>
        </member>
        <member name="M:NServiceBus.AzureServiceBusSubscriptionSettings.DefaultMessageTimeToLive(System.TimeSpan)">
            <summary>
            <remarks> Default is TimeSpan.MaxValue.</remarks>
            </summary>
        </member>
        <member name="M:NServiceBus.AzureServiceBusSubscriptionSettings.EnableBatchedOperations(System.Boolean)">
            <summary>
            <remarks> Default is true.</remarks>
            </summary>
        </member>
        <member name="M:NServiceBus.AzureServiceBusSubscriptionSettings.EnableDeadLetteringOnFilterEvaluationExceptions(System.Boolean)">
            <summary>
            <remarks> Default is false.</remarks>
            </summary>
        </member>
        <member name="M:NServiceBus.AzureServiceBusSubscriptionSettings.EnableDeadLetteringOnMessageExpiration(System.Boolean)">
            <summary>
            <remarks> Default is false.</remarks>
            </summary>
        </member>
        <member name="M:NServiceBus.AzureServiceBusSubscriptionSettings.ForwardDeadLetteredMessagesTo(System.String)">
            <summary>
            <remarks> Default is set not to forward.</remarks>
            </summary>
        </member>
        <member name="M:NServiceBus.AzureServiceBusSubscriptionSettings.ForwardDeadLetteredMessagesTo(System.Func{System.String,System.Boolean},System.String)">
            <summary>
            <remarks> Default is set not to forward.</remarks>
            </summary>
        </member>
        <member name="M:NServiceBus.AzureServiceBusSubscriptionSettings.LockDuration(System.TimeSpan)">
            <summary>
            <remarks> Default is 30 seconds.</remarks>
            </summary>
        </member>
        <member name="M:NServiceBus.AzureServiceBusSubscriptionSettings.MaxDeliveryCount(System.Int32)">
            <summary>
            <remarks> Default is 10.</remarks>
            </summary>
        </member>
        <member name="M:NServiceBus.AzureServiceBusSubscriptionSettings.AutoDeleteOnIdle(System.TimeSpan)">
            <summary>
            <remarks> Default is false.</remarks>
            </summary>
        </member>
        <member name="M:NServiceBus.AzureServiceBusTopicSettings.DescriptionFactory(System.Func{System.String,NServiceBus.Settings.ReadOnlySettings,Microsoft.ServiceBus.Messaging.TopicDescription})">
            <summary>
            Customize topic creation by providing <see cref="T:Microsoft.ServiceBus.Messaging.TopicDescription"/>.
            </summary>
        </member>
        <member name="M:NServiceBus.AzureServiceBusTopicSettings.SupportOrdering(System.Boolean)">
            <summary>
            <remarks> Default is false.</remarks>
            </summary>
        </member>
        <member name="M:NServiceBus.AzureServiceBusTopicSettings.AutoDeleteOnIdle(System.TimeSpan)">
            <summary>
            <remarks> Default is TimeSpan.MaxValue.</remarks>
            </summary>
        </member>
        <member name="M:NServiceBus.AzureServiceBusTopicSettings.DefaultMessageTimeToLive(System.TimeSpan)">
            <summary>
            <remarks> Default is TimeSpan.MaxValue.</remarks>
            </summary>
        </member>
        <member name="M:NServiceBus.AzureServiceBusTopicSettings.DuplicateDetectionHistoryTimeWindow(System.TimeSpan)">
            <summary>
            <remarks> Default is 10 minutes.</remarks>
            </summary>
        </member>
        <member name="M:NServiceBus.AzureServiceBusTopicSettings.EnableBatchedOperations(System.Boolean)">
            <summary>
            <remarks> Default is true.</remarks>
            </summary>
        </member>
        <member name="M:NServiceBus.AzureServiceBusTopicSettings.EnableExpress(System.Boolean)">
            <summary>
            <remarks> Default is false.</remarks>
            </summary>
        </member>
        <member name="M:NServiceBus.AzureServiceBusTopicSettings.EnableExpress(System.Func{System.String,System.Boolean},System.Boolean)">
            <summary>
            <remarks> Default is false.</remarks>
            </summary>
        </member>
        <member name="M:NServiceBus.AzureServiceBusTopicSettings.EnableFilteringMessagesBeforePublishing(System.Boolean)">
            <summary>
            <remarks> Default is false.</remarks>
            </summary>
        </member>
        <member name="M:NServiceBus.AzureServiceBusTopicSettings.EnablePartitioning(System.Boolean)">
            <summary>
            <remarks> Default is false.</remarks>
            <remarks>When using <see cref="T:NServiceBus.ForwardingTopology"/>, partitioning cannot be enabled.</remarks>
            </summary>
        </member>
        <member name="M:NServiceBus.AzureServiceBusTopicSettings.MaxSizeInMegabytes(NServiceBus.SizeInMegabytes)">
            <summary>
            <remarks> Default is 1,024 MB.</remarks>
            </summary>
        </member>
        <member name="M:NServiceBus.AzureServiceBusTopicSettings.RequiresDuplicateDetection(System.Boolean)">
            <summary>
            <remarks> Default is false.</remarks>
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.CanBeNullAttribute">
            <summary>
            Indicates that the value of the marked element could be <c>null</c> sometimes,
            so the check for <c>null</c> is necessary before its usage
            </summary>
            <example><code>
            [CanBeNull] public object Test() { return null; }
            public void UseTest() {
              var p = Test();
              var s = p.ToString(); // Warning: Possible 'System.NullReferenceException'
            }
            </code></example>
        </member>
        <member name="T:JetBrains.Annotations.NotNullAttribute">
            <summary>
            Indicates that the value of the marked element could never be <c>null</c>
            </summary>
            <example><code>
            [NotNull] public object Foo() {
              return null; // Warning: Possible 'null' assignment
            }
            </code></example>
        </member>
        <member name="T:JetBrains.Annotations.ItemNotNullAttribute">
            <summary>
            Indicates that collection or enumerable value does not contain null elements
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.ItemCanBeNullAttribute">
            <summary>
            Indicates that collection or enumerable value can contain null elements
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.StringFormatMethodAttribute">
            <summary>
            Indicates that the marked method builds string by format pattern and (optional) arguments.
            Parameter, which contains format string, should be given in constructor. The format string
            should be in <see cref="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])"/>-like form
            </summary>
            <example><code>
            [StringFormatMethod("message")]
            public void ShowError(string message, params object[] args) { /* do something */ }
            public void Foo() {
              ShowError("Failed: {0}"); // Warning: Non-existing argument in format string
            }
            </code></example>
        </member>
        <member name="M:JetBrains.Annotations.StringFormatMethodAttribute.#ctor(System.String)">
            <param name="formatParameterName">
            Specifies which parameter of an annotated method should be treated as format-string
            </param>
        </member>
        <member name="T:JetBrains.Annotations.ValueProviderAttribute">
            <summary>
            For a parameter that is expected to be one of the limited set of values.
            Specify fields of which type should be used as values for this parameter.
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.InvokerParameterNameAttribute">
            <summary>
            Indicates that the function argument should be string literal and match one
            of the parameters of the caller function. For example, ReSharper annotates
            the parameter of <see cref="T:System.ArgumentNullException"/>
            </summary>
            <example><code>
            public void Foo(string param) {
              if (param == null)
                throw new ArgumentNullException("par"); // Warning: Cannot resolve symbol
            }
            </code></example>
        </member>
        <member name="T:JetBrains.Annotations.NotifyPropertyChangedInvocatorAttribute">
             <summary>
             Indicates that the method is contained in a type that implements
             <c>System.ComponentModel.INotifyPropertyChanged</c> interface and this method
             is used to notify that some property value changed
             </summary>
             <remarks>
             The method should be non-static and conform to one of the supported signatures:
             <list>
             <item><c>NotifyChanged(string)</c></item>
             <item><c>NotifyChanged(params string[])</c></item>
             <item><c>NotifyChanged{T}(Expression{Func{T}})</c></item>
             <item><c>NotifyChanged{T,U}(Expression{Func{T,U}})</c></item>
             <item><c>SetProperty{T}(ref T, T, string)</c></item>
             </list>
             </remarks>
             <example><code>
             public class Foo : INotifyPropertyChanged {
               public event PropertyChangedEventHandler PropertyChanged;
               [NotifyPropertyChangedInvocator]
               protected virtual void NotifyChanged(string propertyName) { ... }
            
               private string _name;
               public string Name {
                 get { return _name; }
                 set { _name = value; NotifyChanged("LastName"); /* Warning */ }
               }
             }
             </code>
             Examples of generated notifications:
             <list>
             <item><c>NotifyChanged("Property")</c></item>
             <item><c>NotifyChanged(() =&gt; Property)</c></item>
             <item><c>NotifyChanged((VM x) =&gt; x.Property)</c></item>
             <item><c>SetProperty(ref myField, value, "Property")</c></item>
             </list>
             </example>
        </member>
        <member name="T:JetBrains.Annotations.ContractAnnotationAttribute">
            <summary>
            Describes dependency between method input and output
            </summary>
            <syntax>
            <p>Function Definition Table syntax:</p>
            <list>
            <item>FDT      ::= FDTRow [;FDTRow]*</item>
            <item>FDTRow   ::= Input =&gt; Output | Output &lt;= Input</item>
            <item>Input    ::= ParameterName: Value [, Input]*</item>
            <item>Output   ::= [ParameterName: Value]* {halt|stop|void|nothing|Value}</item>
            <item>Value    ::= true | false | null | notnull | canbenull</item>
            </list>
            If method has single input parameter, it's name could be omitted.<br/>
            Using <c>halt</c> (or <c>void</c>/<c>nothing</c>, which is the same)
            for method output means that the methos doesn't return normally.<br/>
            <c>canbenull</c> annotation is only applicable for output parameters.<br/>
            You can use multiple <c>[ContractAnnotation]</c> for each FDT row,
            or use single attribute with rows separated by semicolon.<br/>
            </syntax>
            <examples><list>
            <item><code>
            [ContractAnnotation("=> halt")]
            public void TerminationMethod()
            </code></item>
            <item><code>
            [ContractAnnotation("halt &lt;= condition: false")]
            public void Assert(bool condition, string text) // regular assertion method
            </code></item>
            <item><code>
            [ContractAnnotation("s:null => true")]
            public bool IsNullOrEmpty(string s) // string.IsNullOrEmpty()
            </code></item>
            <item><code>
            // A method that returns null if the parameter is null,
            // and not null if the parameter is not null
            [ContractAnnotation("null => null; notnull => notnull")]
            public object Transform(object data) 
            </code></item>
            <item><code>
            [ContractAnnotation("s:null=>false; =>true,result:notnull; =>false, result:null")]
            public bool TryParse(string s, out Person result)
            </code></item>
            </list></examples>
        </member>
        <member name="T:JetBrains.Annotations.LocalizationRequiredAttribute">
            <summary>
            Indicates that marked element should be localized or not
            </summary>
            <example><code>
            [LocalizationRequiredAttribute(true)]
            public class Foo {
              private string str = "my string"; // Warning: Localizable string
            }
            </code></example>
        </member>
        <member name="T:JetBrains.Annotations.CannotApplyEqualityOperatorAttribute">
            <summary>
            Indicates that the value of the marked type (or its derivatives)
            cannot be compared using '==' or '!=' operators and <c>Equals()</c>
            should be used instead. However, using '==' or '!=' for comparison
            with <c>null</c> is always permitted.
            </summary>
            <example><code>
            [CannotApplyEqualityOperator]
            class NoEquality { }
            class UsesNoEquality {
              public void Test() {
                var ca1 = new NoEquality();
                var ca2 = new NoEquality();
                if (ca1 != null) { // OK
                  bool condition = ca1 == ca2; // Warning
                }
              }
            }
            </code></example>
        </member>
        <member name="T:JetBrains.Annotations.BaseTypeRequiredAttribute">
            <summary>
            When applied to a target attribute, specifies a requirement for any type marked
            with the target attribute to implement or inherit specific type or types.
            </summary>
            <example><code>
            [BaseTypeRequired(typeof(IComponent)] // Specify requirement
            public class ComponentAttribute : Attribute { }
            [Component] // ComponentAttribute requires implementing IComponent interface
            public class MyComponent : IComponent { }
            </code></example>
        </member>
        <member name="T:JetBrains.Annotations.UsedImplicitlyAttribute">
            <summary>
            Indicates that the marked symbol is used implicitly
            (e.g. via reflection, in external library), so this symbol
            will not be marked as unused (as well as by other usage inspections)
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.MeansImplicitUseAttribute">
            <summary>
            Should be used on attributes and causes ReSharper
            to not mark symbols marked with such attributes as unused
            (as well as by other usage inspections)
            </summary>
        </member>
        <member name="F:JetBrains.Annotations.ImplicitUseKindFlags.Access">
            <summary>Only entity marked with attribute considered used</summary>
        </member>
        <member name="F:JetBrains.Annotations.ImplicitUseKindFlags.Assign">
            <summary>Indicates implicit assignment to a member</summary>
        </member>
        <member name="F:JetBrains.Annotations.ImplicitUseKindFlags.InstantiatedWithFixedConstructorSignature">
            <summary>
            Indicates implicit instantiation of a type with fixed constructor signature.
            That means any unused constructor parameters won't be reported as such.
            </summary>
        </member>
        <member name="F:JetBrains.Annotations.ImplicitUseKindFlags.InstantiatedNoFixedConstructorSignature">
            <summary>Indicates implicit instantiation of a type</summary>
        </member>
        <member name="T:JetBrains.Annotations.ImplicitUseTargetFlags">
            <summary>
            Specify what is considered used implicitly when marked
            with <see cref="T:JetBrains.Annotations.MeansImplicitUseAttribute"/> or <see cref="T:JetBrains.Annotations.UsedImplicitlyAttribute"/>
            </summary>
        </member>
        <member name="F:JetBrains.Annotations.ImplicitUseTargetFlags.Members">
            <summary>Members of entity marked with attribute are considered used</summary>
        </member>
        <member name="F:JetBrains.Annotations.ImplicitUseTargetFlags.WithMembers">
            <summary>Entity marked with attribute and all its members considered used</summary>
        </member>
        <member name="T:JetBrains.Annotations.PublicAPIAttribute">
            <summary>
            This attribute is intended to mark publicly available API
            which should not be removed and so is treated as used
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.InstantHandleAttribute">
            <summary>
            Tells code analysis engine if the parameter is completely handled
            when the invoked method is on stack. If the parameter is a delegate,
            indicates that delegate is executed while the method is executed.
            If the parameter is an enumerable, indicates that it is enumerated
            while the method is executed
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.PureAttribute">
            <summary>
            Indicates that a method does not make any observable state changes.
            The same as <c>System.Diagnostics.Contracts.PureAttribute</c>
            </summary>
            <example><code>
            [Pure] private int Multiply(int x, int y) { return x * y; }
            public void Foo() {
              const int a = 2, b = 2;
              Multiply(a, b); // Waring: Return value of pure method is not used
            }
            </code></example>
        </member>
        <member name="T:JetBrains.Annotations.PathReferenceAttribute">
            <summary>
            Indicates that a parameter is a path to a file or a folder within a web project.
            Path can be relative or absolute, starting from web root (~)
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.AspMvcActionAttribute">
            <summary>
            ASP.NET MVC attribute. If applied to a parameter, indicates that the parameter
            is an MVC action. If applied to a method, the MVC action name is calculated
            implicitly from the context. Use this attribute for custom wrappers similar to
            <c>System.Web.Mvc.Html.ChildActionExtensions.RenderAction(HtmlHelper, String)</c>
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.AspMvcAreaAttribute">
            <summary>
            ASP.NET MVC attribute. Indicates that a parameter is an MVC area.
            Use this attribute for custom wrappers similar to
            <c>System.Web.Mvc.Html.ChildActionExtensions.RenderAction(HtmlHelper, String)</c>
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.AspMvcControllerAttribute">
            <summary>
            ASP.NET MVC attribute. If applied to a parameter, indicates that the parameter is
            an MVC controller. If applied to a method, the MVC controller name is calculated
            implicitly from the context. Use this attribute for custom wrappers similar to
            <c>System.Web.Mvc.Html.ChildActionExtensions.RenderAction(HtmlHelper, String, String)</c>
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.AspMvcMasterAttribute">
            <summary>
            ASP.NET MVC attribute. Indicates that a parameter is an MVC Master. Use this attribute
            for custom wrappers similar to <c>System.Web.Mvc.Controller.View(String, String)</c>
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.AspMvcModelTypeAttribute">
            <summary>
            ASP.NET MVC attribute. Indicates that a parameter is an MVC model type. Use this attribute
            for custom wrappers similar to <c>System.Web.Mvc.Controller.View(String, Object)</c>
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.AspMvcPartialViewAttribute">
            <summary>
            ASP.NET MVC attribute. If applied to a parameter, indicates that the parameter is an MVC
            partial view. If applied to a method, the MVC partial view name is calculated implicitly
            from the context. Use this attribute for custom wrappers similar to
            <c>System.Web.Mvc.Html.RenderPartialExtensions.RenderPartial(HtmlHelper, String)</c>
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.AspMvcSupressViewErrorAttribute">
            <summary>
            ASP.NET MVC attribute. Allows disabling inspections for MVC views within a class or a method
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.AspMvcDisplayTemplateAttribute">
            <summary>
            ASP.NET MVC attribute. Indicates that a parameter is an MVC display template.
            Use this attribute for custom wrappers similar to 
            <c>System.Web.Mvc.Html.DisplayExtensions.DisplayForModel(HtmlHelper, String)</c>
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.AspMvcEditorTemplateAttribute">
            <summary>
            ASP.NET MVC attribute. Indicates that a parameter is an MVC editor template.
            Use this attribute for custom wrappers similar to
            <c>System.Web.Mvc.Html.EditorExtensions.EditorForModel(HtmlHelper, String)</c>
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.AspMvcTemplateAttribute">
            <summary>
            ASP.NET MVC attribute. Indicates that a parameter is an MVC template.
            Use this attribute for custom wrappers similar to
            <c>System.ComponentModel.DataAnnotations.UIHintAttribute(System.String)</c>
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.AspMvcViewAttribute">
            <summary>
            ASP.NET MVC attribute. If applied to a parameter, indicates that the parameter
            is an MVC view. If applied to a method, the MVC view name is calculated implicitly
            from the context. Use this attribute for custom wrappers similar to
            <c>System.Web.Mvc.Controller.View(Object)</c>
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.AspMvcActionSelectorAttribute">
            <summary>
            ASP.NET MVC attribute. When applied to a parameter of an attribute,
            indicates that this parameter is an MVC action name
            </summary>
            <example><code>
            [ActionName("Foo")]
            public ActionResult Login(string returnUrl) {
              ViewBag.ReturnUrl = Url.Action("Foo"); // OK
              return RedirectToAction("Bar"); // Error: Cannot resolve action
            }
            </code></example>
        </member>
        <member name="T:JetBrains.Annotations.RazorSectionAttribute">
            <summary>
            Razor attribute. Indicates that a parameter or a method is a Razor section.
            Use this attribute for custom wrappers similar to 
            <c>System.Web.WebPages.WebPageBase.RenderSection(String)</c>
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.CollectionAccessAttribute">
            <summary>
            Indicates how method invocation affects content of the collection
            </summary>
        </member>
        <member name="F:JetBrains.Annotations.CollectionAccessType.None">
            <summary>Method does not use or modify content of the collection</summary>
        </member>
        <member name="F:JetBrains.Annotations.CollectionAccessType.Read">
            <summary>Method only reads content of the collection but does not modify it</summary>
        </member>
        <member name="F:JetBrains.Annotations.CollectionAccessType.ModifyExistingContent">
            <summary>Method can change content of the collection but does not add new elements</summary>
        </member>
        <member name="F:JetBrains.Annotations.CollectionAccessType.UpdatedContent">
            <summary>Method can add new elements to the collection</summary>
        </member>
        <member name="T:JetBrains.Annotations.AssertionMethodAttribute">
            <summary>
            Indicates that the marked method is assertion method, i.e. it halts control flow if
            one of the conditions is satisfied. To set the condition, mark one of the parameters with 
            <see cref="T:JetBrains.Annotations.AssertionConditionAttribute"/> attribute
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.AssertionConditionAttribute">
            <summary>
            Indicates the condition parameter of the assertion method. The method itself should be
            marked by <see cref="T:JetBrains.Annotations.AssertionMethodAttribute"/> attribute. The mandatory argument of
            the attribute is the assertion type.
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.AssertionConditionType">
            <summary>
            Specifies assertion type. If the assertion method argument satisfies the condition,
            then the execution continues. Otherwise, execution is assumed to be halted
            </summary>
        </member>
        <member name="F:JetBrains.Annotations.AssertionConditionType.IS_TRUE">
            <summary>Marked parameter should be evaluated to true</summary>
        </member>
        <member name="F:JetBrains.Annotations.AssertionConditionType.IS_FALSE">
            <summary>Marked parameter should be evaluated to false</summary>
        </member>
        <member name="F:JetBrains.Annotations.AssertionConditionType.IS_NULL">
            <summary>Marked parameter should be evaluated to null value</summary>
        </member>
        <member name="F:JetBrains.Annotations.AssertionConditionType.IS_NOT_NULL">
            <summary>Marked parameter should be evaluated to not null value</summary>
        </member>
        <member name="T:JetBrains.Annotations.LinqTunnelAttribute">
            <summary>
            Indicates that method is pure LINQ method, with postponed enumeration (like Enumerable.Select,
            .Where). This annotation allows inference of [InstantHandle] annotation for parameters
            of delegate type by analyzing LINQ method chains.
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.NoEnumerationAttribute">
            <summary>
            Indicates that IEnumerable, passed as parameter, is not enumerated.
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.RegexPatternAttribute">
            <summary>
            Indicates that parameter is regular expression pattern.
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.XamlItemsControlAttribute">
            <summary>
            XAML attribute. Indicates the type that has <c>ItemsSource</c> property and should be
            treated as <c>ItemsControl</c>-derived type, to enable inner  items <c>DataContext</c>
            type resolve.
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.XamlItemBindingOfItemsControlAttribute">
            <summary>
            XAML attibute. Indicates the property of some <c>BindingBase</c>-derived type, that
            is used to bind some item of <c>ItemsControl</c>-derived type. This annotation will
            enable the <c>DataContext</c> type resolve for XAML bindings for such properties.
            </summary>
            <remarks>
            Property should have the tree ancestor of the <c>ItemsControl</c> type or
            marked with the <see cref="T:JetBrains.Annotations.XamlItemsControlAttribute"/> attribute.
            </remarks>
        </member>
        <member name="T:JetBrains.Annotations.NoReorder">
            <summary>
            Prevents the Member Reordering feature from tossing members of the marked class.
            </summary>
            <remarks>
            The attribute must be mentioned in your member reordering patterns.
            </remarks>
        </member>
    </members>
</doc>
